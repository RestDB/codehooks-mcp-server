#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
    ListToolsRequestSchema,
    CallToolRequestSchema,
    ErrorCode,
    McpError,
    CompleteRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { promisify } from "util";
import { exec as execCallback } from "child_process";
import { promises as fs } from 'fs';
import path from 'path';

const exec = promisify(execCallback);

// Configuration and types
interface CodehooksConfig {
    projectId: string;
    space: string;
    adminToken: string;
}

const config: CodehooksConfig = {
    projectId: process.env.CODEHOOKS_PROJECT_NAME || "",
    space: process.env.CODEHOOKS_SPACE || "dev",
    adminToken: process.env.CODEHOOKS_ADMIN_TOKEN || "",
};

// Tool schemas with proper typing
const queryCollectionSchema = z.object({
    collection: z.string(),
    query: z.string().optional(),
    count: z.boolean().optional(),
    delete: z.boolean().optional(),
    update: z.string().optional(),
    replace: z.string().optional(),
    useindex: z.string().optional(),
    start: z.string().optional(),
    end: z.string().optional(),
    limit: z.number().optional(),
    fields: z.string().optional(),
    sort: z.string().optional(),
    offset: z.number().optional(),
    enqueue: z.string().optional(),
    pretty: z.boolean().optional(),
    reverse: z.boolean().optional(),
    table: z.boolean().optional(),
    csv: z.boolean().optional()
});

const deployCodeSchema = z.object({
    files: z.array(z.object({
        path: z.string(),
        content: z.string()
    })),
    main: z.string().optional(),
    json: z.boolean().optional(),
    projectId: z.string().optional(),
    spaceId: z.string().optional()
});

const fileUploadSchema = z.object({
    // Single file upload fields
    src: z.string().optional().describe("Source file path (for files in container)"),
    filename: z.string().optional().describe("Target filename (required when using content)"),
    content: z.string().optional().describe("File content as text or base64"),
    encoding: z.enum(["text", "base64"]).optional().default("text").describe("Content encoding type"),
    target: z.string().optional().describe("Target path on server"),
    // Multiple files upload fields
    files: z.array(z.object({
        path: z.string().describe("Relative path within directory (e.g. 'src/index.js', 'images/logo.png')"),
        content: z.string().describe("File content as text or base64"),
        encoding: z.enum(["text", "base64"]).optional().default("text").describe("Content encoding type")
    })).optional().describe("Array of files to upload as a directory")
});

const fileDeleteSchema = z.object({
    filename: z.string().describe("File to delete from server"),
});

const fileListSchema = z.object({
    path: z.string().optional().describe("Path to list files from"),
});

const verifySchema = z.object({
    dir: z.string().optional().describe("Directory to verify/compile (defaults to current dir)"),
});

const createIndexSchema = z.object({
    collection: z.string().describe("Collection name"),
    index: z.string().describe("Field(s) to add to query index"),
});

const dropIndexSchema = z.object({
    collection: z.string().describe("Collection name"),
    index: z.string().describe("Field(s) to remove from query index"),
});

const createCollectionSchema = z.object({
    collection: z.string().describe("Name of collection to create"),
});

const dropCollectionSchema = z.object({
    collection: z.string().describe("Name of collection to drop"),
});

const schemaSchema = z.object({
    collection: z.string().describe("Collection name"),
    schema: z.string().describe("JSON schema to add"),
});

const removeSchemaSchema = z.object({
    collection: z.string().describe("Collection to remove schema from"),
});

const capCollectionSchema = z.object({
    collection: z.string().describe("Collection name"),
    cap: z.number().describe("Maximum number of documents"),
    capdelay: z.number().optional().describe("Delay in seconds before capping"),
});

const uncapCollectionSchema = z.object({
    collection: z.string().describe("Collection to remove cap from"),
});

const importSchema = z.object({
    filepath: z.string().describe("File path to import from"),
    collection: z.string().describe("Collection to import into"),
    separator: z.string().optional().describe("CSV separator character"),
    encoding: z.string().optional().describe("File encoding"),
});

const exportSchema = z.object({
    collection: z.string().describe("Collection to export"),
    filepath: z.string().optional().describe("File to save export data"),
    csv: z.boolean().optional().describe("Export to CSV format"),
});

// Add type inference
type QueryCollectionArgs = z.infer<typeof queryCollectionSchema>;
type DeployCodeArgs = z.infer<typeof deployCodeSchema>;
type FileUploadArgs = z.infer<typeof fileUploadSchema>;
type FileDeleteArgs = z.infer<typeof fileDeleteSchema>;
type FileListArgs = z.infer<typeof fileListSchema>;
type VerifyArgs = z.infer<typeof verifySchema>;
type CreateIndexArgs = z.infer<typeof createIndexSchema>;
type DropIndexArgs = z.infer<typeof dropIndexSchema>;
type CreateCollectionArgs = z.infer<typeof createCollectionSchema>;
type DropCollectionArgs = z.infer<typeof dropCollectionSchema>;
type SchemaArgs = z.infer<typeof schemaSchema>;
type RemoveSchemaArgs = z.infer<typeof removeSchemaSchema>;
type CapCollectionArgs = z.infer<typeof capCollectionSchema>;
type UncapCollectionArgs = z.infer<typeof uncapCollectionSchema>;
type ImportArgs = z.infer<typeof importSchema>;
type ExportArgs = z.infer<typeof exportSchema>;

// Tool definitions with JSON Schema for tools/list
const tools = [
    {
        name: "query_collection",
        description: "Query data from a collection. Supports URL-style, regex, and MongoDB-style JSON queries with comparison operators.",
        schema: queryCollectionSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection name" },
                query: { type: "string", description: "Query expression. Supports multiple formats: URL-style ('name=Polly&type=Parrot'), regex ('name=/^po/'), or MongoDB-style JSON ('{\"name\": \"Polly\", \"age\": {\"$gt\": 5}}' for complex queries with operators like $gt, $lt, $gte, $lte, $ne, $in, $nin, $exists, $regex)" },
                count: { type: "boolean", description: "Count query results" },
                delete: { type: "boolean", description: "Delete all items from query result" },
                update: { type: "string", description: "Patch all items from query result with JSON string '{...}'" },
                replace: { type: "string", description: "Replace all items from query result with JSON string '{...}'" },
                useindex: { type: "string", description: "Use an indexed field to scan data in query" },
                start: { type: "string", description: "Start value for index scan" },
                end: { type: "string", description: "End value for index scan" },
                limit: { type: "number", description: "Limit query result" },
                fields: { type: "string", description: "Comma separated list of fields to include" },
                sort: { type: "string", description: "Comma separated list of fields to sort by" },
                offset: { type: "number", description: "Skip items before returning data in query result" },
                enqueue: { type: "string", description: "Add query result to queue topic" },
                pretty: { type: "boolean", description: "Output data with formatting and colors" },
                reverse: { type: "boolean", description: "Scan index in reverse order" },
                table: { type: "boolean", description: "Output data as formatted table" },
                csv: { type: "boolean", description: "Output data in CSV format" }
            },
            required: ["collection"]
        }
    },
    {
        name: "deploy_code",
        description: "Deploy JavaScript code to Codehooks.io project. For generating compatible backend code, use the comprehensive ChatGPT prompt template at https://codehooks.io/docs/chatgpt-backend-api-prompt which provides examples for REST APIs, NoSQL database operations, key-value store, worker queues, job scheduling, validation schemas, and more. Note: Codehooks.io has CORS built-in by default, so no additional CORS middleware is needed.",
        schema: deployCodeSchema,
        inputSchema: {
            type: "object",
            properties: {
                files: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            path: { type: "string", description: "File path relative to project root (e.g. 'index.js', 'src/utils.js')" },
                            content: { type: "string", description: "File content" }
                        },
                        required: ["path", "content"]
                    },
                    description: "Array of files to deploy"
                },
                main: { type: "string", description: "Application main file (defaults to 'index')" },
                json: { type: "boolean", description: "Output JSON format" },
                projectId: { type: "string", description: "Project ID" },
                spaceId: { type: "string", description: "Space ID", default: "dev" }
            },
            required: ["files"]
        }
    },
    {
        name: "file_upload",
        description: "Upload files to server",
        schema: fileUploadSchema,
        inputSchema: {
            type: "object",
            properties: {
                src: { type: "string", description: "Source file path (for files in container)" },
                filename: { type: "string", description: "Target filename (required when using content)" },
                content: { type: "string", description: "File content as text or base64" },
                encoding: { type: "string", enum: ["text", "base64"], default: "text", description: "Content encoding type" },
                target: { type: "string", description: "Target path on server" },
                files: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            path: { type: "string", description: "Relative path within directory (e.g. 'src/index.js')" },
                            content: { type: "string", description: "File content as text or base64" },
                            encoding: { type: "string", enum: ["text", "base64"], default: "text", description: "Content encoding type" }
                        },
                        required: ["path", "content"]
                    },
                    description: "Array of files to upload as a directory (alternative to single file)"
                }
            },
            description: "Use either: 1) 'src' for file path, 2) 'filename'+'content' for single file, or 3) 'files' array for directory"
        }
    },
    {
        name: "file_delete",
        description: "Delete a file from server",
        schema: fileDeleteSchema,
        inputSchema: {
            type: "object",
            properties: {
                filename: { type: "string", description: "File to delete from server" }
            },
            required: ["filename"]
        }
    },
    {
        name: "file_list",
        description: "List files from server",
        schema: fileListSchema,
        inputSchema: {
            type: "object",
            properties: {
                path: { type: "string", description: "Path to list files from" }
            }
        }
    },
    {
        name: "verify",
        description: "Verify/compile code",
        schema: verifySchema,
        inputSchema: {
            type: "object",
            properties: {
                dir: { type: "string", description: "Directory to verify/compile (defaults to current dir)" }
            }
        }
    },
    {
        name: "create_index",
        description: "Add field(s) to a query index",
        schema: createIndexSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection name" },
                index: { type: "string", description: "Field(s) to add to query index" }
            },
            required: ["collection", "index"]
        }
    },
    {
        name: "drop_index",
        description: "Remove field(s) from a query index",
        schema: dropIndexSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection name" },
                index: { type: "string", description: "Field(s) to remove from query index" }
            },
            required: ["collection", "index"]
        }
    },
    {
        name: "create_collection",
        description: "Create a new collection",
        schema: createCollectionSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Name of collection to create" }
            },
            required: ["collection"]
        }
    },
    {
        name: "drop_collection",
        description: "Delete a collection",
        schema: dropCollectionSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Name of collection to drop" }
            },
            required: ["collection"]
        }
    },
    {
        name: "add_schema",
        description: "Add a JSON schema to a collection",
        schema: schemaSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection name" },
                schema: { type: "string", description: "JSON schema to add" }
            },
            required: ["collection", "schema"]
        }
    },
    {
        name: "remove_schema",
        description: "Remove JSON schema from a collection",
        schema: removeSchemaSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection to remove schema from" }
            },
            required: ["collection"]
        }
    },
    {
        name: "cap_collection",
        description: "Cap a collection",
        schema: capCollectionSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection name" },
                cap: { type: "number", description: "Maximum number of documents" },
                capdelay: { type: "number", description: "Delay in seconds before capping" }
            },
            required: ["collection", "cap"]
        }
    },
    {
        name: "uncap_collection",
        description: "Remove cap from a collection",
        schema: uncapCollectionSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection to remove cap from" }
            },
            required: ["collection"]
        }
    },
    {
        name: "import",
        description: "Import data from file",
        schema: importSchema,
        inputSchema: {
            type: "object",
            properties: {
                filepath: { type: "string", description: "File path to import from" },
                collection: { type: "string", description: "Collection to import into" },
                separator: { type: "string", description: "CSV separator character" },
                encoding: { type: "string", description: "File encoding" }
            },
            required: ["filepath", "collection"]
        }
    },
    {
        name: "export",
        description: "Export data",
        schema: exportSchema,
        inputSchema: {
            type: "object",
            properties: {
                collection: { type: "string", description: "Collection to export" },
                filepath: { type: "string", description: "File to save export data" },
                csv: { type: "boolean", description: "Export to CSV format" }
            },
            required: ["collection"]
        }
    }
];

// Initialize MCP server
const server = new Server(
    {
        name: "codehooks-mcp",
        version: "1.0.0",
    },
    {
        capabilities: {
            tools: {
                listChanged: true
            },
        },
    }
);

// Helper function to execute coho CLI commands
async function executeCohoCommand(command: string): Promise<string> {
    console.error(`Executing command: coho ${command.replace(config.adminToken, '***')}`);
    try {
        const { stdout, stderr } = await exec(`coho ${command} --admintoken ${config.adminToken} `);
        if (stderr) {
            console.error(`Command output to stderr:`, stderr);
        }
        console.error(`Command successful`);
        return stdout || stderr; // Return either stdout or stderr as some commands output to stderr
    } catch (error: any) {
        console.error(`Command failed: ${error?.message || 'Unknown error'}`);
        throw new McpError(ErrorCode.InvalidRequest, `Command failed: ${error?.message || 'Unknown error'}`);
    }
}

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async (request) => {
    console.error("Received tools/list request");
    return {
        tools: tools.map(({ name, description, inputSchema }) => ({
            name,
            description,
            inputSchema
        }))
    };
});

// Handle tool execution
server.setRequestHandler(CallToolRequestSchema, async (request) => {
    console.error(`Received tools/call request for: ${request.params.name}`);

    if (!config.projectId) {
        console.error("CODEHOOKS_PROJECT_NAME is not set, so you need to supply the Agent with the project name");
    }

    if (!config.adminToken) {
        console.error("CODEHOOKS_ADMIN_TOKEN is not set, so you need to supply the Agent with the admin token");
        throw new McpError(ErrorCode.InvalidRequest, "Missing required configuration: CODEHOOKS_ADMIN_TOKEN");
    }

    const tool = tools.find(t => t.name === request.params.name);
    if (!tool) {
        console.error(`Unknown tool requested: ${request.params.name}`);
        throw new McpError(ErrorCode.MethodNotFound, "Tool not found");
    }

    try {
        // Validate arguments against the Zod schema
        const args = tool.schema.parse(request.params.arguments);

        switch (tool.name) {
            case "query_collection": {
                const {
                    collection,
                    query = "",
                    count = false,
                    delete: shouldDelete = false,
                    update,
                    replace,
                    useindex,
                    start,
                    end,
                    limit = count ? undefined : 100,
                    fields,
                    sort,
                    offset,
                    enqueue,
                    pretty = false,
                    reverse = false,
                    table = false,
                    csv = false
                } = args as QueryCollectionArgs;

                console.error(`Querying collection: ${collection}`);

                const queryParams = [
                    `--collection ${collection}`,
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    query ? `--query '${query}'` : '',
                    count ? '--count' : '',
                    shouldDelete ? '--delete' : '',
                    update ? `--update '${update}'` : '',
                    replace ? `--replace '${replace}'` : '',
                    useindex ? `--useindex ${useindex}` : '',
                    start ? `--start '${start}'` : '',
                    end ? `--end '${end}'` : '',
                    limit ? `--limit ${limit}` : '',
                    fields ? `--fields '${fields}'` : '',
                    sort ? `--sort '${sort}'` : '',
                    offset ? `--offset ${offset}` : '',
                    enqueue ? `--enqueue ${enqueue}` : '',
                    pretty ? '--pretty' : '',
                    reverse ? '--reverse' : '',
                    table ? '--table' : '',
                    csv ? '--csv' : ''
                ].filter(Boolean).join(' ');

                const result = await executeCohoCommand(`query ${queryParams}`);

                // If the output is CSV or table format, return as is
                if (csv || table || pretty) {
                    return {
                        content: [
                            {
                                type: "text",
                                text: result
                            }
                        ],
                        isError: false
                    };
                }

                // Otherwise parse and format as JSON
                return {
                    content: [
                        {
                            type: "text",
                            text: JSON.stringify(JSON.parse(result), null, 2)
                        }
                    ],
                    isError: false
                };
            }

            case "deploy_code": {
                const {
                    files,
                    main = "index",
                    json = false,
                    projectId,
                    spaceId
                } = args as DeployCodeArgs;

                console.error(`Deploying ${files.length} files`);
                const tmpDir = await fs.mkdtemp('/tmp/codehooks-deploy-');
                console.error('Created temporary directory:', tmpDir);

                try {
                    // Write all files to the temporary directory with proper formatting
                    for (const file of files) {
                        const filePath = path.join(tmpDir, file.path);
                        // Ensure directory exists
                        await fs.mkdir(path.dirname(filePath), { recursive: true });
                        console.error(`Writing file: ${filePath}`);

                        if (file.path === 'package.json') {
                            // Create a properly structured package.json
                            const defaultPackage = {
                                name: projectId || config.projectId || "codehooks-project",
                                version: "1.0.0",
                                description: "Codehooks project",
                                main: `${main}.js`,
                                scripts: {
                                    test: "echo \"Error: no test specified\" && exit 1"
                                },
                                author: "",
                                license: "ISC",
                                dependencies: {
                                    "codehooks-js": "latest"
                                }
                            };

                            // Merge with any existing package.json content
                            let packageJson;
                            try {
                                packageJson = JSON.parse(file.content);
                                packageJson = { ...defaultPackage, ...packageJson };
                            } catch (e) {
                                console.error('Invalid package.json content, using default');
                                packageJson = defaultPackage;
                            }

                            // Write package.json with proper formatting
                            await fs.writeFile(filePath, JSON.stringify(packageJson, null, 2));
                        } else {
                            await fs.writeFile(filePath, file.content);
                        }
                    }

                    // Log directory contents
                    console.error('Directory contents before npm install:');
                    const { stdout: lsOutput } = await exec('ls -la', { cwd: tmpDir });
                    console.error(lsOutput);

                    // Install dependencies
                    try {
                        console.error('Installing dependencies...');
                        const { stdout: npmStdout, stderr: npmStderr } = await exec('npm install', { cwd: tmpDir });
                        if (npmStderr) console.error('npm install stderr:', npmStderr);
                        console.error('npm install stdout:', npmStdout);

                        // Log directory contents after npm install
                        console.error('Directory contents after npm install:');
                        const { stdout: lsOutput2 } = await exec('ls -la', { cwd: tmpDir });
                        console.error(lsOutput2);
                    } catch (error: any) {
                        console.error('npm install error:', error);
                        throw new McpError(ErrorCode.InvalidRequest, `Failed to install dependencies: ${error.message}`);
                    }

                    // Change working directory to tmpDir
                    const originalCwd = process.cwd();
                    try {
                        process.chdir(tmpDir);
                        console.error('Changed working directory to:', tmpDir);

                        // Log file contents before deployment
                        console.error('File contents before deployment:');
                        for (const file of files) {
                            console.error(`\n=== ${file.path} ===`);
                            const content = await fs.readFile(path.join(tmpDir, file.path), 'utf8');
                            console.error(content);
                        }

                        // Construct command exactly like the working direct command
                        const deployCommand = [
                            'coho deploy',
                            `--projectname ${projectId || config.projectId}`,
                            `--space ${spaceId || config.space}`,
                            `--main ${main}`,
                            `--admintoken ${config.adminToken}`,
                            json ? '--json' : ''
                        ].filter(Boolean).join(' ');

                        console.error('Executing deploy command...');
                        const { stdout, stderr } = await exec(deployCommand);
                        console.error('Deploy stdout:', stdout);
                        if (stderr) console.error('Deploy stderr:', stderr);

                        // Only clean up on success
                        await fs.rm(tmpDir, { recursive: true, force: true });
                        console.error('Cleaned up temporary directory:', tmpDir);

                        return {
                            content: [
                                {
                                    type: "text",
                                    text: stdout || stderr || "Deployment successful"
                                }
                            ],
                            isError: false
                        };
                    } finally {
                        // Restore original working directory
                        process.chdir(originalCwd);
                        console.error('Restored working directory to:', originalCwd);
                    }
                } catch (error: any) {
                    console.error(`Deployment failed. Temporary directory ${tmpDir} preserved for inspection.`);
                    console.error('Error:', error);
                    throw error;
                }
            }

            case "file_upload": {
                const { src, filename, content, encoding = "text", target, files } = args as FileUploadArgs;

                // Check if this is a multiple files upload (directory)
                if (files && files.length > 0) {
                    // Multiple files upload (directory)
                    const tempDir = `/tmp/upload-${Date.now()}`;

                    try {
                        // Create temp directory
                        await fs.mkdir(tempDir, { recursive: true });

                        // Write all files to temp directory with proper structure
                        for (const file of files) {
                            const fullPath = path.join(tempDir, file.path);

                            // Ensure directory exists for this file
                            await fs.mkdir(path.dirname(fullPath), { recursive: true });

                            if (file.encoding === "base64") {
                                // Decode base64 content to binary
                                const buffer = Buffer.from(file.content, 'base64');
                                await fs.writeFile(fullPath, buffer);
                            } else {
                                // Write text content
                                await fs.writeFile(fullPath, file.content, 'utf8');
                            }
                        }

                        // Upload the entire temp directory
                        const uploadParams = [
                            `--project ${config.projectId}`,
                            `--space ${config.space}`,
                            `"${tempDir}"`,
                            target ? `--target "${target}"` : ''
                        ].filter(Boolean).join(' ');

                        const result = await executeCohoCommand(`upload ${uploadParams}`);

                        // Clean up temp directory
                        await fs.rm(tempDir, { recursive: true, force: true });

                        return {
                            content: [
                                {
                                    type: "text",
                                    text: result
                                }
                            ],
                            isError: false
                        };
                    } catch (error: any) {
                        // Clean up temp directory on error
                        try {
                            await fs.rm(tempDir, { recursive: true, force: true });
                        } catch (unlinkError) {
                            // Ignore cleanup errors
                        }
                        throw error;
                    }
                } else if (content && filename) {
                    // Content-based upload (base64 or text)
                    const tempPath = `/tmp/${filename}`;

                    try {
                        if (encoding === "base64") {
                            // Decode base64 content to binary
                            const buffer = Buffer.from(content, 'base64');
                            await fs.writeFile(tempPath, buffer);
                        } else {
                            // Write text content
                            await fs.writeFile(tempPath, content, 'utf8');
                        }

                        // Upload the temporary file
                        const uploadParams = [
                            `--project ${config.projectId}`,
                            `--space ${config.space}`,
                            `"${tempPath}"`,
                            target ? `--target "${target}"` : ''
                        ].filter(Boolean).join(' ');

                        const result = await executeCohoCommand(`upload ${uploadParams}`);

                        // Clean up temporary file
                        await fs.unlink(tempPath);

                        return {
                            content: [
                                {
                                    type: "text",
                                    text: result
                                }
                            ],
                            isError: false
                        };
                    } catch (error: any) {
                        // Clean up temporary file on error
                        try {
                            await fs.unlink(tempPath);
                        } catch (unlinkError) {
                            // Ignore cleanup errors
                        }
                        throw error;
                    }
                } else if (src) {
                    // File path-based upload (traditional)
                    const uploadParams = [
                        `--project ${config.projectId}`,
                        `--space ${config.space}`,
                        `"${src}"`,
                        target ? `--target "${target}"` : ''
                    ].filter(Boolean).join(' ');

                    const result = await executeCohoCommand(`upload ${uploadParams}`);
                    return {
                        content: [
                            {
                                type: "text",
                                text: result
                            }
                        ],
                        isError: false
                    };
                } else {
                    throw new McpError(ErrorCode.InvalidRequest, "Either 'src' (file path) or 'content' + 'filename' or 'files' array must be provided");
                }
            }

            case "file_delete": {
                const { filename } = args as FileDeleteArgs;
                const deleteParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${filename}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`delete ${deleteParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "file_list": {
                const { path } = args as FileListArgs;
                const fileParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    path ? `"${path}"` : ''
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`files ${fileParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "verify": {
                const { dir } = args as VerifyArgs;
                const verifyParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    dir ? `"${dir}"` : ''
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`verify ${verifyParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "create_index": {
                const { collection, index } = args as CreateIndexArgs;
                const indexParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`,
                    `"${index}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`createindex ${indexParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "drop_index": {
                const { collection, index } = args as DropIndexArgs;
                const dropIndexParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`,
                    `"${index}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`dropindex ${dropIndexParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "create_collection": {
                const { collection } = args as CreateCollectionArgs;
                const createCollParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`createcoll ${createCollParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "drop_collection": {
                const { collection } = args as DropCollectionArgs;
                const dropCollParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`dropcoll ${dropCollParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "add_schema": {
                const { collection, schema } = args as SchemaArgs;
                const schemaParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`,
                    `'${schema}'`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`schema ${schemaParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "remove_schema": {
                const { collection } = args as RemoveSchemaArgs;
                const removeSchemaParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`remove-schema ${removeSchemaParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "cap_collection": {
                const { collection, cap, capdelay } = args as CapCollectionArgs;
                const capParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`,
                    `${cap}`,
                    capdelay ? `--capdelay ${capdelay}` : ''
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`cap ${capParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "uncap_collection": {
                const { collection } = args as UncapCollectionArgs;
                const uncapParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`uncap ${uncapParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "import": {
                const { filepath, collection, separator, encoding } = args as ImportArgs;
                const importParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `-f "${filepath}"`,
                    `-c "${collection}"`,
                    separator ? `--separator "${separator}"` : '',
                    encoding ? `--encoding "${encoding}"` : ''
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`import ${importParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            case "export": {
                const { collection, filepath, csv } = args as ExportArgs;
                const exportParams = [
                    `--project ${config.projectId}`,
                    `--space ${config.space}`,
                    `"${collection}"`,
                    filepath ? `-f "${filepath}"` : '',
                    csv ? '--csv' : ''
                ].filter(Boolean).join(' ');
                const result = await executeCohoCommand(`export ${exportParams}`);
                return {
                    content: [
                        {
                            type: "text",
                            text: result
                        }
                    ],
                    isError: false
                };
            }

            default: {
                throw new McpError(ErrorCode.MethodNotFound, "Tool not found");
            }
        }
    } catch (error) {
        if (error instanceof McpError) {
            throw error;
        }
        if (error instanceof z.ZodError) {
            return {
                content: [
                    {
                        type: "text",
                        text: `Invalid arguments: ${error.message}`
                    }
                ],
                isError: true
            };
        }
        return {
            content: [
                {
                    type: "text",
                    text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`
                }
            ],
            isError: true
        };
    }
});

// Add completion handler
server.setRequestHandler(CompleteRequestSchema, async (request) => {
    console.error("Received completion request");
    return {
        completion: {
            choices: [
                {
                    text: "Example completion",
                },
            ],
        },
    };
});

// Start the server
console.error("=== MCP Server Starting ===");
console.error("Environment:");
console.error(`- Project: ${config.projectId || 'Not set, you need to supply the Agent with the project name'}`);
console.error(`- Space: ${config.space}`);
console.error(`- Admin token present: ${!!config.adminToken}`);

console.error("\nTesting coho CLI availability...");
try {
    const { stdout } = await exec('coho --version');
    console.error(`- coho CLI version: ${stdout.trim()}`);
} catch (error) {
    console.error("- Error: coho CLI not found or not working");
    console.error(error);
}

console.error("\nStarting MCP transport...");
const transport = new StdioServerTransport();
console.error("Connecting to transport...");
await server.connect(transport);
console.error("Server ready for requests"); 